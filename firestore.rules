/**
 * This ruleset enforces a security model for an internal-facing application
 * (like a Barista or Staff app) where any authenticated user has full
 * management access to all data. This is a common pattern for tools used by a
 * trusted group of employees.
 *
 * Core Philosophy:
 * Access is granted based on authentication status alone. If a user is signed
 * in, they are considered a trusted operator (e.g., a barista) and can create,
 * read, update, and delete any customer or order record. Unauthenticated users
 * have no access.
 *
 * Data Structure:
 * The data is organized into a top-level 'customers' collection. Each document
 * in this collection represents a unique customer. Nested under each customer
 * document is an 'orders' subcollection containing that customer's order history.
 * - /customers/{customerId}
 * - /customers/{customerId}/orders/{orderId}
 *
 * Key Security Decisions:
 * - Any Authenticated User Is an Admin: The rules do not distinguish between
 *   different types of users. As long as a user is signed in, they have
 *   permission to manage the entire dataset.
 * - Relational Integrity: The rules enforce that an 'Order' document's internal
 *   `customerId` field must match the parent `customerId` in the path. This
 *   prevents orders from being incorrectly associated with the wrong customer.
 * - Default Deny: All access is denied by default. Rules explicitly grant
 *   permissions only to authenticated users.
 *
 * Denormalization for Authorization:
 * This ruleset does not require complex denormalization because the security
 * model is simple (is the user signed in?). However, it enforces relational
 * integrity by requiring the `customerId` to be present on each `Order` document,
 * which is a form of denormalization that simplifies rules and client-side queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to improve readability and maintainability.

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if a document already exists. Used for update and delete operations.
     */
    function documentExists() {
      return resource != null;
    }

    /**
     * Validates that the user is signed in and the document being modified exists.
     * This is the standard check for all update and delete operations.
     */
    function canModifyExistingDoc() {
      return isSignedIn() && documentExists();
    }

    /**
     * On create, validates that the new Customer document contains an `id` field
     * that matches the document's ID from the path.
     */
    function hasValidCustomerDataOnCreate(customerId) {
      return request.resource.data.id == customerId;
    }

    /**
     * On update, ensures the Customer's `id` field cannot be changed.
     */
    function customerDataIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates relational integrity for a new Order.
     * The order's internal `id` must match the document ID, and its `customerId`
     * must match the parent customer's document ID from the path.
     */
    function hasValidOrderDataOnCreate(customerId, orderId) {
      let incomingData = request.resource.data;
      return incomingData.id == orderId && incomingData.customerId == customerId;
    }

    /**
     * On update, ensures an Order's `id` and `customerId` fields cannot be changed.
     */
    function orderDataIsImmutable() {
      let incomingData = request.resource.data;
      let existingData = resource.data;
      return incomingData.id == existingData.id && incomingData.customerId == existingData.customerId;
    }

    /**
     * @description Manages customer profiles. Any authenticated user (e.g., a barista)
     *              can create, view, and manage any customer record.
     * @path /customers/{customerId}
     * @allow (get) An authenticated user reads a customer profile with ID '123-456-7890'.
     * @deny (get) An unauthenticated user attempts to read a customer profile.
     * @principle Grants full CRUD access to any authenticated user, treating them as trusted staff.
     */
    match /customers/{customerId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && hasValidCustomerDataOnCreate(customerId);
      allow update: if canModifyExistingDoc() && customerDataIsImmutable();
      allow delete: if canModifyExistingDoc();
    }

    /**
     * @description Manages orders for a specific customer. Any authenticated user can
     *              manage orders for any customer.
     * @path /customers/{customerId}/orders/{orderId}
     * @allow (create) An authenticated user creates a new order for customer '123-456-7890'.
     * @deny (create) An authenticated user tries to create an order where the order data's
     *         `customerId` does not match the `{customerId}` in the path.
     * @principle Enforces relational integrity to ensure an order is always linked to the
     *            correct customer parent document.
     */
    match /customers/{customerId}/orders/{orderId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && hasValidOrderDataOnCreate(customerId, orderId);
      allow update: if canModifyExistingDoc() && orderDataIsImmutable();
      allow delete: if canModifyExistingDoc();
    }
  }
}